// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'size.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$SizeAttributeTearOff {
  const _$SizeAttributeTearOff();

  _SizeAttribute call(double size) {
    return _SizeAttribute(
      size,
    );
  }

  HeightAttribute height(double size) {
    return HeightAttribute(
      size,
    );
  }

  MaxHeightAttribute maxHeight(double size) {
    return MaxHeightAttribute(
      size,
    );
  }

  MinHeightAttribute minHeight(double size) {
    return MinHeightAttribute(
      size,
    );
  }

  WidthAttribute width(double size) {
    return WidthAttribute(
      size,
    );
  }

  MaxWidthAttribute maxWidth(double size) {
    return MaxWidthAttribute(
      size,
    );
  }

  MinWidthAttribute minWidth(double size) {
    return MinWidthAttribute(
      size,
    );
  }
}

/// @nodoc
const $SizeAttribute = _$SizeAttributeTearOff();

/// @nodoc
mixin _$SizeAttribute {
  double get size => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(double size) $default, {
    required TResult Function(double size) height,
    required TResult Function(double size) maxHeight,
    required TResult Function(double size) minHeight,
    required TResult Function(double size) width,
    required TResult Function(double size) maxWidth,
    required TResult Function(double size) minWidth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(double size)? $default, {
    TResult Function(double size)? height,
    TResult Function(double size)? maxHeight,
    TResult Function(double size)? minHeight,
    TResult Function(double size)? width,
    TResult Function(double size)? maxWidth,
    TResult Function(double size)? minWidth,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_SizeAttribute value) $default, {
    required TResult Function(HeightAttribute value) height,
    required TResult Function(MaxHeightAttribute value) maxHeight,
    required TResult Function(MinHeightAttribute value) minHeight,
    required TResult Function(WidthAttribute value) width,
    required TResult Function(MaxWidthAttribute value) maxWidth,
    required TResult Function(MinWidthAttribute value) minWidth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_SizeAttribute value)? $default, {
    TResult Function(HeightAttribute value)? height,
    TResult Function(MaxHeightAttribute value)? maxHeight,
    TResult Function(MinHeightAttribute value)? minHeight,
    TResult Function(WidthAttribute value)? width,
    TResult Function(MaxWidthAttribute value)? maxWidth,
    TResult Function(MinWidthAttribute value)? minWidth,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SizeAttributeCopyWith<SizeAttribute> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SizeAttributeCopyWith<$Res> {
  factory $SizeAttributeCopyWith(
          SizeAttribute value, $Res Function(SizeAttribute) then) =
      _$SizeAttributeCopyWithImpl<$Res>;
  $Res call({double size});
}

/// @nodoc
class _$SizeAttributeCopyWithImpl<$Res>
    implements $SizeAttributeCopyWith<$Res> {
  _$SizeAttributeCopyWithImpl(this._value, this._then);

  final SizeAttribute _value;
  // ignore: unused_field
  final $Res Function(SizeAttribute) _then;

  @override
  $Res call({
    Object? size = freezed,
  }) {
    return _then(_value.copyWith(
      size: size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
abstract class _$SizeAttributeCopyWith<$Res>
    implements $SizeAttributeCopyWith<$Res> {
  factory _$SizeAttributeCopyWith(
          _SizeAttribute value, $Res Function(_SizeAttribute) then) =
      __$SizeAttributeCopyWithImpl<$Res>;
  @override
  $Res call({double size});
}

/// @nodoc
class __$SizeAttributeCopyWithImpl<$Res>
    extends _$SizeAttributeCopyWithImpl<$Res>
    implements _$SizeAttributeCopyWith<$Res> {
  __$SizeAttributeCopyWithImpl(
      _SizeAttribute _value, $Res Function(_SizeAttribute) _then)
      : super(_value, (v) => _then(v as _SizeAttribute));

  @override
  _SizeAttribute get _value => super._value as _SizeAttribute;

  @override
  $Res call({
    Object? size = freezed,
  }) {
    return _then(_SizeAttribute(
      size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_SizeAttribute extends _SizeAttribute {
  _$_SizeAttribute(this.size) : super._();

  @override
  final double size;

  @override
  String toString() {
    return 'SizeAttribute(size: $size)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SizeAttribute &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(size);

  @JsonKey(ignore: true)
  @override
  _$SizeAttributeCopyWith<_SizeAttribute> get copyWith =>
      __$SizeAttributeCopyWithImpl<_SizeAttribute>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(double size) $default, {
    required TResult Function(double size) height,
    required TResult Function(double size) maxHeight,
    required TResult Function(double size) minHeight,
    required TResult Function(double size) width,
    required TResult Function(double size) maxWidth,
    required TResult Function(double size) minWidth,
  }) {
    return $default(size);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(double size)? $default, {
    TResult Function(double size)? height,
    TResult Function(double size)? maxHeight,
    TResult Function(double size)? minHeight,
    TResult Function(double size)? width,
    TResult Function(double size)? maxWidth,
    TResult Function(double size)? minWidth,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(size);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_SizeAttribute value) $default, {
    required TResult Function(HeightAttribute value) height,
    required TResult Function(MaxHeightAttribute value) maxHeight,
    required TResult Function(MinHeightAttribute value) minHeight,
    required TResult Function(WidthAttribute value) width,
    required TResult Function(MaxWidthAttribute value) maxWidth,
    required TResult Function(MinWidthAttribute value) minWidth,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_SizeAttribute value)? $default, {
    TResult Function(HeightAttribute value)? height,
    TResult Function(MaxHeightAttribute value)? maxHeight,
    TResult Function(MinHeightAttribute value)? minHeight,
    TResult Function(WidthAttribute value)? width,
    TResult Function(MaxWidthAttribute value)? maxWidth,
    TResult Function(MinWidthAttribute value)? minWidth,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class _SizeAttribute extends SizeAttribute {
  factory _SizeAttribute(double size) = _$_SizeAttribute;
  _SizeAttribute._() : super._();

  @override
  double get size => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SizeAttributeCopyWith<_SizeAttribute> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HeightAttributeCopyWith<$Res>
    implements $SizeAttributeCopyWith<$Res> {
  factory $HeightAttributeCopyWith(
          HeightAttribute value, $Res Function(HeightAttribute) then) =
      _$HeightAttributeCopyWithImpl<$Res>;
  @override
  $Res call({double size});
}

/// @nodoc
class _$HeightAttributeCopyWithImpl<$Res>
    extends _$SizeAttributeCopyWithImpl<$Res>
    implements $HeightAttributeCopyWith<$Res> {
  _$HeightAttributeCopyWithImpl(
      HeightAttribute _value, $Res Function(HeightAttribute) _then)
      : super(_value, (v) => _then(v as HeightAttribute));

  @override
  HeightAttribute get _value => super._value as HeightAttribute;

  @override
  $Res call({
    Object? size = freezed,
  }) {
    return _then(HeightAttribute(
      size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$HeightAttribute extends HeightAttribute {
  _$HeightAttribute(this.size) : super._();

  @override
  final double size;

  @override
  String toString() {
    return 'SizeAttribute.height(size: $size)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is HeightAttribute &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(size);

  @JsonKey(ignore: true)
  @override
  $HeightAttributeCopyWith<HeightAttribute> get copyWith =>
      _$HeightAttributeCopyWithImpl<HeightAttribute>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(double size) $default, {
    required TResult Function(double size) height,
    required TResult Function(double size) maxHeight,
    required TResult Function(double size) minHeight,
    required TResult Function(double size) width,
    required TResult Function(double size) maxWidth,
    required TResult Function(double size) minWidth,
  }) {
    return height(size);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(double size)? $default, {
    TResult Function(double size)? height,
    TResult Function(double size)? maxHeight,
    TResult Function(double size)? minHeight,
    TResult Function(double size)? width,
    TResult Function(double size)? maxWidth,
    TResult Function(double size)? minWidth,
    required TResult orElse(),
  }) {
    if (height != null) {
      return height(size);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_SizeAttribute value) $default, {
    required TResult Function(HeightAttribute value) height,
    required TResult Function(MaxHeightAttribute value) maxHeight,
    required TResult Function(MinHeightAttribute value) minHeight,
    required TResult Function(WidthAttribute value) width,
    required TResult Function(MaxWidthAttribute value) maxWidth,
    required TResult Function(MinWidthAttribute value) minWidth,
  }) {
    return height(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_SizeAttribute value)? $default, {
    TResult Function(HeightAttribute value)? height,
    TResult Function(MaxHeightAttribute value)? maxHeight,
    TResult Function(MinHeightAttribute value)? minHeight,
    TResult Function(WidthAttribute value)? width,
    TResult Function(MaxWidthAttribute value)? maxWidth,
    TResult Function(MinWidthAttribute value)? minWidth,
    required TResult orElse(),
  }) {
    if (height != null) {
      return height(this);
    }
    return orElse();
  }
}

abstract class HeightAttribute extends SizeAttribute {
  factory HeightAttribute(double size) = _$HeightAttribute;
  HeightAttribute._() : super._();

  @override
  double get size => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $HeightAttributeCopyWith<HeightAttribute> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MaxHeightAttributeCopyWith<$Res>
    implements $SizeAttributeCopyWith<$Res> {
  factory $MaxHeightAttributeCopyWith(
          MaxHeightAttribute value, $Res Function(MaxHeightAttribute) then) =
      _$MaxHeightAttributeCopyWithImpl<$Res>;
  @override
  $Res call({double size});
}

/// @nodoc
class _$MaxHeightAttributeCopyWithImpl<$Res>
    extends _$SizeAttributeCopyWithImpl<$Res>
    implements $MaxHeightAttributeCopyWith<$Res> {
  _$MaxHeightAttributeCopyWithImpl(
      MaxHeightAttribute _value, $Res Function(MaxHeightAttribute) _then)
      : super(_value, (v) => _then(v as MaxHeightAttribute));

  @override
  MaxHeightAttribute get _value => super._value as MaxHeightAttribute;

  @override
  $Res call({
    Object? size = freezed,
  }) {
    return _then(MaxHeightAttribute(
      size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$MaxHeightAttribute extends MaxHeightAttribute {
  _$MaxHeightAttribute(this.size) : super._();

  @override
  final double size;

  @override
  String toString() {
    return 'SizeAttribute.maxHeight(size: $size)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MaxHeightAttribute &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(size);

  @JsonKey(ignore: true)
  @override
  $MaxHeightAttributeCopyWith<MaxHeightAttribute> get copyWith =>
      _$MaxHeightAttributeCopyWithImpl<MaxHeightAttribute>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(double size) $default, {
    required TResult Function(double size) height,
    required TResult Function(double size) maxHeight,
    required TResult Function(double size) minHeight,
    required TResult Function(double size) width,
    required TResult Function(double size) maxWidth,
    required TResult Function(double size) minWidth,
  }) {
    return maxHeight(size);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(double size)? $default, {
    TResult Function(double size)? height,
    TResult Function(double size)? maxHeight,
    TResult Function(double size)? minHeight,
    TResult Function(double size)? width,
    TResult Function(double size)? maxWidth,
    TResult Function(double size)? minWidth,
    required TResult orElse(),
  }) {
    if (maxHeight != null) {
      return maxHeight(size);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_SizeAttribute value) $default, {
    required TResult Function(HeightAttribute value) height,
    required TResult Function(MaxHeightAttribute value) maxHeight,
    required TResult Function(MinHeightAttribute value) minHeight,
    required TResult Function(WidthAttribute value) width,
    required TResult Function(MaxWidthAttribute value) maxWidth,
    required TResult Function(MinWidthAttribute value) minWidth,
  }) {
    return maxHeight(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_SizeAttribute value)? $default, {
    TResult Function(HeightAttribute value)? height,
    TResult Function(MaxHeightAttribute value)? maxHeight,
    TResult Function(MinHeightAttribute value)? minHeight,
    TResult Function(WidthAttribute value)? width,
    TResult Function(MaxWidthAttribute value)? maxWidth,
    TResult Function(MinWidthAttribute value)? minWidth,
    required TResult orElse(),
  }) {
    if (maxHeight != null) {
      return maxHeight(this);
    }
    return orElse();
  }
}

abstract class MaxHeightAttribute extends SizeAttribute {
  factory MaxHeightAttribute(double size) = _$MaxHeightAttribute;
  MaxHeightAttribute._() : super._();

  @override
  double get size => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $MaxHeightAttributeCopyWith<MaxHeightAttribute> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MinHeightAttributeCopyWith<$Res>
    implements $SizeAttributeCopyWith<$Res> {
  factory $MinHeightAttributeCopyWith(
          MinHeightAttribute value, $Res Function(MinHeightAttribute) then) =
      _$MinHeightAttributeCopyWithImpl<$Res>;
  @override
  $Res call({double size});
}

/// @nodoc
class _$MinHeightAttributeCopyWithImpl<$Res>
    extends _$SizeAttributeCopyWithImpl<$Res>
    implements $MinHeightAttributeCopyWith<$Res> {
  _$MinHeightAttributeCopyWithImpl(
      MinHeightAttribute _value, $Res Function(MinHeightAttribute) _then)
      : super(_value, (v) => _then(v as MinHeightAttribute));

  @override
  MinHeightAttribute get _value => super._value as MinHeightAttribute;

  @override
  $Res call({
    Object? size = freezed,
  }) {
    return _then(MinHeightAttribute(
      size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$MinHeightAttribute extends MinHeightAttribute {
  _$MinHeightAttribute(this.size) : super._();

  @override
  final double size;

  @override
  String toString() {
    return 'SizeAttribute.minHeight(size: $size)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MinHeightAttribute &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(size);

  @JsonKey(ignore: true)
  @override
  $MinHeightAttributeCopyWith<MinHeightAttribute> get copyWith =>
      _$MinHeightAttributeCopyWithImpl<MinHeightAttribute>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(double size) $default, {
    required TResult Function(double size) height,
    required TResult Function(double size) maxHeight,
    required TResult Function(double size) minHeight,
    required TResult Function(double size) width,
    required TResult Function(double size) maxWidth,
    required TResult Function(double size) minWidth,
  }) {
    return minHeight(size);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(double size)? $default, {
    TResult Function(double size)? height,
    TResult Function(double size)? maxHeight,
    TResult Function(double size)? minHeight,
    TResult Function(double size)? width,
    TResult Function(double size)? maxWidth,
    TResult Function(double size)? minWidth,
    required TResult orElse(),
  }) {
    if (minHeight != null) {
      return minHeight(size);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_SizeAttribute value) $default, {
    required TResult Function(HeightAttribute value) height,
    required TResult Function(MaxHeightAttribute value) maxHeight,
    required TResult Function(MinHeightAttribute value) minHeight,
    required TResult Function(WidthAttribute value) width,
    required TResult Function(MaxWidthAttribute value) maxWidth,
    required TResult Function(MinWidthAttribute value) minWidth,
  }) {
    return minHeight(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_SizeAttribute value)? $default, {
    TResult Function(HeightAttribute value)? height,
    TResult Function(MaxHeightAttribute value)? maxHeight,
    TResult Function(MinHeightAttribute value)? minHeight,
    TResult Function(WidthAttribute value)? width,
    TResult Function(MaxWidthAttribute value)? maxWidth,
    TResult Function(MinWidthAttribute value)? minWidth,
    required TResult orElse(),
  }) {
    if (minHeight != null) {
      return minHeight(this);
    }
    return orElse();
  }
}

abstract class MinHeightAttribute extends SizeAttribute {
  factory MinHeightAttribute(double size) = _$MinHeightAttribute;
  MinHeightAttribute._() : super._();

  @override
  double get size => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $MinHeightAttributeCopyWith<MinHeightAttribute> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WidthAttributeCopyWith<$Res>
    implements $SizeAttributeCopyWith<$Res> {
  factory $WidthAttributeCopyWith(
          WidthAttribute value, $Res Function(WidthAttribute) then) =
      _$WidthAttributeCopyWithImpl<$Res>;
  @override
  $Res call({double size});
}

/// @nodoc
class _$WidthAttributeCopyWithImpl<$Res>
    extends _$SizeAttributeCopyWithImpl<$Res>
    implements $WidthAttributeCopyWith<$Res> {
  _$WidthAttributeCopyWithImpl(
      WidthAttribute _value, $Res Function(WidthAttribute) _then)
      : super(_value, (v) => _then(v as WidthAttribute));

  @override
  WidthAttribute get _value => super._value as WidthAttribute;

  @override
  $Res call({
    Object? size = freezed,
  }) {
    return _then(WidthAttribute(
      size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$WidthAttribute extends WidthAttribute {
  _$WidthAttribute(this.size) : super._();

  @override
  final double size;

  @override
  String toString() {
    return 'SizeAttribute.width(size: $size)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WidthAttribute &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(size);

  @JsonKey(ignore: true)
  @override
  $WidthAttributeCopyWith<WidthAttribute> get copyWith =>
      _$WidthAttributeCopyWithImpl<WidthAttribute>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(double size) $default, {
    required TResult Function(double size) height,
    required TResult Function(double size) maxHeight,
    required TResult Function(double size) minHeight,
    required TResult Function(double size) width,
    required TResult Function(double size) maxWidth,
    required TResult Function(double size) minWidth,
  }) {
    return width(size);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(double size)? $default, {
    TResult Function(double size)? height,
    TResult Function(double size)? maxHeight,
    TResult Function(double size)? minHeight,
    TResult Function(double size)? width,
    TResult Function(double size)? maxWidth,
    TResult Function(double size)? minWidth,
    required TResult orElse(),
  }) {
    if (width != null) {
      return width(size);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_SizeAttribute value) $default, {
    required TResult Function(HeightAttribute value) height,
    required TResult Function(MaxHeightAttribute value) maxHeight,
    required TResult Function(MinHeightAttribute value) minHeight,
    required TResult Function(WidthAttribute value) width,
    required TResult Function(MaxWidthAttribute value) maxWidth,
    required TResult Function(MinWidthAttribute value) minWidth,
  }) {
    return width(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_SizeAttribute value)? $default, {
    TResult Function(HeightAttribute value)? height,
    TResult Function(MaxHeightAttribute value)? maxHeight,
    TResult Function(MinHeightAttribute value)? minHeight,
    TResult Function(WidthAttribute value)? width,
    TResult Function(MaxWidthAttribute value)? maxWidth,
    TResult Function(MinWidthAttribute value)? minWidth,
    required TResult orElse(),
  }) {
    if (width != null) {
      return width(this);
    }
    return orElse();
  }
}

abstract class WidthAttribute extends SizeAttribute {
  factory WidthAttribute(double size) = _$WidthAttribute;
  WidthAttribute._() : super._();

  @override
  double get size => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $WidthAttributeCopyWith<WidthAttribute> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MaxWidthAttributeCopyWith<$Res>
    implements $SizeAttributeCopyWith<$Res> {
  factory $MaxWidthAttributeCopyWith(
          MaxWidthAttribute value, $Res Function(MaxWidthAttribute) then) =
      _$MaxWidthAttributeCopyWithImpl<$Res>;
  @override
  $Res call({double size});
}

/// @nodoc
class _$MaxWidthAttributeCopyWithImpl<$Res>
    extends _$SizeAttributeCopyWithImpl<$Res>
    implements $MaxWidthAttributeCopyWith<$Res> {
  _$MaxWidthAttributeCopyWithImpl(
      MaxWidthAttribute _value, $Res Function(MaxWidthAttribute) _then)
      : super(_value, (v) => _then(v as MaxWidthAttribute));

  @override
  MaxWidthAttribute get _value => super._value as MaxWidthAttribute;

  @override
  $Res call({
    Object? size = freezed,
  }) {
    return _then(MaxWidthAttribute(
      size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$MaxWidthAttribute extends MaxWidthAttribute {
  _$MaxWidthAttribute(this.size) : super._();

  @override
  final double size;

  @override
  String toString() {
    return 'SizeAttribute.maxWidth(size: $size)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MaxWidthAttribute &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(size);

  @JsonKey(ignore: true)
  @override
  $MaxWidthAttributeCopyWith<MaxWidthAttribute> get copyWith =>
      _$MaxWidthAttributeCopyWithImpl<MaxWidthAttribute>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(double size) $default, {
    required TResult Function(double size) height,
    required TResult Function(double size) maxHeight,
    required TResult Function(double size) minHeight,
    required TResult Function(double size) width,
    required TResult Function(double size) maxWidth,
    required TResult Function(double size) minWidth,
  }) {
    return maxWidth(size);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(double size)? $default, {
    TResult Function(double size)? height,
    TResult Function(double size)? maxHeight,
    TResult Function(double size)? minHeight,
    TResult Function(double size)? width,
    TResult Function(double size)? maxWidth,
    TResult Function(double size)? minWidth,
    required TResult orElse(),
  }) {
    if (maxWidth != null) {
      return maxWidth(size);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_SizeAttribute value) $default, {
    required TResult Function(HeightAttribute value) height,
    required TResult Function(MaxHeightAttribute value) maxHeight,
    required TResult Function(MinHeightAttribute value) minHeight,
    required TResult Function(WidthAttribute value) width,
    required TResult Function(MaxWidthAttribute value) maxWidth,
    required TResult Function(MinWidthAttribute value) minWidth,
  }) {
    return maxWidth(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_SizeAttribute value)? $default, {
    TResult Function(HeightAttribute value)? height,
    TResult Function(MaxHeightAttribute value)? maxHeight,
    TResult Function(MinHeightAttribute value)? minHeight,
    TResult Function(WidthAttribute value)? width,
    TResult Function(MaxWidthAttribute value)? maxWidth,
    TResult Function(MinWidthAttribute value)? minWidth,
    required TResult orElse(),
  }) {
    if (maxWidth != null) {
      return maxWidth(this);
    }
    return orElse();
  }
}

abstract class MaxWidthAttribute extends SizeAttribute {
  factory MaxWidthAttribute(double size) = _$MaxWidthAttribute;
  MaxWidthAttribute._() : super._();

  @override
  double get size => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $MaxWidthAttributeCopyWith<MaxWidthAttribute> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MinWidthAttributeCopyWith<$Res>
    implements $SizeAttributeCopyWith<$Res> {
  factory $MinWidthAttributeCopyWith(
          MinWidthAttribute value, $Res Function(MinWidthAttribute) then) =
      _$MinWidthAttributeCopyWithImpl<$Res>;
  @override
  $Res call({double size});
}

/// @nodoc
class _$MinWidthAttributeCopyWithImpl<$Res>
    extends _$SizeAttributeCopyWithImpl<$Res>
    implements $MinWidthAttributeCopyWith<$Res> {
  _$MinWidthAttributeCopyWithImpl(
      MinWidthAttribute _value, $Res Function(MinWidthAttribute) _then)
      : super(_value, (v) => _then(v as MinWidthAttribute));

  @override
  MinWidthAttribute get _value => super._value as MinWidthAttribute;

  @override
  $Res call({
    Object? size = freezed,
  }) {
    return _then(MinWidthAttribute(
      size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$MinWidthAttribute extends MinWidthAttribute {
  _$MinWidthAttribute(this.size) : super._();

  @override
  final double size;

  @override
  String toString() {
    return 'SizeAttribute.minWidth(size: $size)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MinWidthAttribute &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(size);

  @JsonKey(ignore: true)
  @override
  $MinWidthAttributeCopyWith<MinWidthAttribute> get copyWith =>
      _$MinWidthAttributeCopyWithImpl<MinWidthAttribute>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(double size) $default, {
    required TResult Function(double size) height,
    required TResult Function(double size) maxHeight,
    required TResult Function(double size) minHeight,
    required TResult Function(double size) width,
    required TResult Function(double size) maxWidth,
    required TResult Function(double size) minWidth,
  }) {
    return minWidth(size);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(double size)? $default, {
    TResult Function(double size)? height,
    TResult Function(double size)? maxHeight,
    TResult Function(double size)? minHeight,
    TResult Function(double size)? width,
    TResult Function(double size)? maxWidth,
    TResult Function(double size)? minWidth,
    required TResult orElse(),
  }) {
    if (minWidth != null) {
      return minWidth(size);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_SizeAttribute value) $default, {
    required TResult Function(HeightAttribute value) height,
    required TResult Function(MaxHeightAttribute value) maxHeight,
    required TResult Function(MinHeightAttribute value) minHeight,
    required TResult Function(WidthAttribute value) width,
    required TResult Function(MaxWidthAttribute value) maxWidth,
    required TResult Function(MinWidthAttribute value) minWidth,
  }) {
    return minWidth(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_SizeAttribute value)? $default, {
    TResult Function(HeightAttribute value)? height,
    TResult Function(MaxHeightAttribute value)? maxHeight,
    TResult Function(MinHeightAttribute value)? minHeight,
    TResult Function(WidthAttribute value)? width,
    TResult Function(MaxWidthAttribute value)? maxWidth,
    TResult Function(MinWidthAttribute value)? minWidth,
    required TResult orElse(),
  }) {
    if (minWidth != null) {
      return minWidth(this);
    }
    return orElse();
  }
}

abstract class MinWidthAttribute extends SizeAttribute {
  factory MinWidthAttribute(double size) = _$MinWidthAttribute;
  MinWidthAttribute._() : super._();

  @override
  double get size => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $MinWidthAttributeCopyWith<MinWidthAttribute> get copyWith =>
      throw _privateConstructorUsedError;
}
